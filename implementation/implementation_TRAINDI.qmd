---
title: "Implementation of trainDI.R"
subtitle: "Supplementary to the thesis 'Development of a local data point density approach to assess the Area of Applicability for spatial prediction models'"
author: "Fabian Schumacher"
format: 
  html:
    toc: true
    toc-title: Implementation of trainDI.R
    html-math-method: katex
editor: visual
repo-url: https://github.com/LOEK-RS/CAST4ecology
---

## Introduction

In the course of the `LPD` Layer implementation, only the calculation of an additional parameter has arisen within the `trainDI` function. The `avrgQD` parameter specifies for how many training data points a test data point lies on average within the calculated threshold. Since every training sample will be in a test fold exactly one time in the course of the cross validation procedure, the `avrgQD` can be seen as the average quantitative density of all training samples.

## Implementation

### Calculate `trainLPD`

For every cross-validation iteration a `m x n` matrix with the distances from each point in the test fold to each point in the train fold was calculated, with `m` being the number of test points and `n` being the number of training samples. Each row of the matrix for the given CV-iteration holds the ordered distances of the test points to the n-nearest neighbors in the train fold. Dividing this matrix by the average train distance, results in matrix with the corresponding Dissimilarity Indices. From this matrix a count for each test sample with the number of training samples it lies within the threshold is derived and the average of these values is calculated and appended to a list which holds this average value for all CV-iterations. After going through the cross-validation iterations, the average of the values in the filled list is then taken again and rounded to set the final `avrgQD` value.

```{r trainLPD maxLPD avrgLPD, eval=FALSE, attr.source='.numberLines startFrom="242"'}
if (LPD == TRUE && !is.null(CVtest) && !is.null(CVtrain)) {
    # Calculate trainLPD
    trainLPD <- c()
    for (j in  seq(CVtest)) {
      testFoldDist <-
        .alldistfun(train[CVtest[[j]],], train[CVtrain[[j]],], method)

      DItestFoldDist <- testFoldDist / trainDist_avrgmean

      count_list <-
        apply(DItestFoldDist, 1, function(row)
          sum(row < thres))

      trainLPD <- append(trainLPD, count_list)
    }

    # Calculate average LPD in trainData
    avrgLPD <- round(mean(trainLPD))

    # Optimal maxLPD ----
    if (maxLPD == "opt") {
      maxLPD <- stats::quantile(trainLPD, 0.25,na.rm=TRUE)
      message(paste("maxLPD was set to", maxLPD))
    }
  }
```

## Set `trainLPD` and additional parameters

In this code segment the previously calculated `trainLPD` and the parameters `avrgLPD` and `maxLPD` are set so that they will be part of the returned `trainDI` object.

```{r return trainDI onject, eval=FALSE, attr.source='.numberLines startFrom="271"'}
aoa_results = list(
  train = train_backup,
  weight = weight,
  variables = variables,
  catvars = catupdate$catvars,
  scaleparam = scaleparam,
  trainDist_avrg = trainDist_avrg,
  trainDist_avrgmean = trainDist_avrgmean,
  trainDI = TrainDI,
  threshold = thres,
  method = method
)

if (LPD == TRUE && !is.null(CVtest) && !is.null(CVtrain)) {
  aoa_results$trainLPD <- trainLPD
  aoa_results$avrgLPD <- avrgLPD
  aoa_results$maxLPD <- maxLPD
}

class(aoa_results) = "trainDI"

return(aoa_results)
```
